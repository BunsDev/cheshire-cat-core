import time
import base64
from io import BytesIO
from enum import Enum
from typing import List, Optional, Literal
import requests
from PIL import Image

from pydantic import BaseModel, Field, ConfigDict, computed_field
from langchain_core.messages import AIMessage, HumanMessage, SystemMessage, BaseMessage

from cat.utils import BaseModelDict, deprecation_warning
from cat.log import log


class Role(Enum):
    """
    Enum representing the roles involved in a conversation.

    Attributes
    ----------
    AI : str
        Represents an artificial intelligence role.
    Human : str
        Represents a human role.
    """

    AI = "AI"
    Human = "Human"


class ModelInteraction(BaseModel):
    """
    Base class for interactions with models, capturing essential attributes common to all model interactions.

    Attributes
    ----------
    model_type : Literal["llm", "embedder"]
        The type of model involved in the interaction, either a large language model (LLM) or an embedder.
    source : str
        The source from which the interaction originates.
    prompt : str
        The prompt or input provided to the model.
    input_tokens : int
        The number of input tokens processed by the model.
    started_at : float
        The timestamp when the interaction started. Defaults to the current time.
    """

    model_type: Literal["llm", "embedder"]
    source: str
    prompt: str
    input_tokens: int
    started_at: float = Field(default_factory=lambda: time.time())

    model_config = ConfigDict(
        protected_namespaces=()
    )


class LLMModelInteraction(ModelInteraction):
    """
    Represents an interaction with a large language model (LLM).

    Inherits from ModelInteraction and adds specific attributes related to LLM interactions.

    Attributes
    ----------
    model_type : Literal["llm"]
        The type of model, which is fixed to "llm".
    reply : str
        The response generated by the LLM.
    output_tokens : int
        The number of output tokens generated by the LLM.
    ended_at : float
        The timestamp when the interaction ended.
    """

    model_type: Literal["llm"] = Field(default="llm")
    reply: str
    output_tokens: int
    ended_at: float


class EmbedderModelInteraction(ModelInteraction):
    """
    Represents an interaction with an embedding model.

    Inherits from ModelInteraction and includes attributes specific to embedding interactions.

    Attributes
    ----------
    model_type : Literal["embedder"]
        The type of model, which is fixed to "embedder".
    source : str
        The source of the interaction, defaulting to "recall".
    reply : List[float]
        The embeddings generated by the embedder.
    """
    model_type: Literal["embedder"] = Field(default="embedder")
    source: str = Field(default="recall")
    reply: List[float]


class MessageWhy(BaseModelDict):
    """
    A class for encapsulating the context and reasoning behind a message, providing details on 
    input, intermediate steps, memory, and interactions with models.

    Attributes
    ----------
    input : str
        The initial input message that triggered the response.
    intermediate_steps : List
        A list capturing intermediate steps or actions taken as part of processing the message.
    memory : dict
        A dictionary containing relevant memory information used during the processing of the message.
    model_interactions : List[Union[LLMModelInteraction, EmbedderModelInteraction]]
        A list of interactions with language or embedding models, detailing how models were used in generating 
        or understanding the message context.
    """

    input: str
    intermediate_steps: List
    memory: dict
    model_interactions: List[LLMModelInteraction | EmbedderModelInteraction]


class BaseMessage(BaseModelDict):
    """
    Base class for messages, containing common attributes shared by all message types.

    Attributes
    ----------
    user_id : str
        Unique identifier for the user associated with the message.
    who : str
        The name of the message author.
    text : Optional[str]
        The text content of the message.
    image : Optional[str]
        Image file URLs or base64 data URIs that represent image associated with the message.
    audio : Optional[str]
        Audio file URLs or base64 data URIs that represent audio associated with the message.
    why : Optional[MessageWhy]
        Additional contextual information related to the message.
    """

    user_id: str   
    who: str
    text: Optional[str] = None
    image: Optional[str] = None
    audio: Optional[str] = None


class CatMessage(BaseMessage):
    """
    Represents a Cat message.

    Parameters
    ----------
    user_id : str
        Unique identifier for the user associated with the message.
    text : Optional[str], default=None
        The text content of the message.
    image : Optional[str], default=None
        Image file URLs or base64 data URIs that represent image associated with the message.
    audio : Optional[str], default=None
        Audio file URLs or base64 data URIs that represent audio associated with the message.
    why : Optional[MessageWhy], default=None
        Additional contextual information related to the message.
    who : str, default="AI"
        The name of the message author, by default "AI".
    content : Optional[str], default=None
        Deprecated. The text content of the message. Use `text` instead.

    Attributes
    ----------
    type : str
        The type of message. Defaults to "chat".
    user_id : str
        Unique identifier for the user associated with the message.
    who : str
        The name of the message author, by default AI.
    text : Optional[str]
        The text content of the message.
    image : Optional[str]
        Image file URLs or base64 data URIs that represent image associated with the message.
    audio : Optional[str]
        Audio file URLs or base64 data URIs that represent audio associated with the message.
    why : Optional[MessageWhy]
        Additional contextual information related to the message.

    Notes
    -----
    - The `content` parameter and attribute are deprecated. Use `text` instead.
    """

    type: str = "chat" # For now is always "chat" and is not used
    who: str = "AI"
    why: Optional[MessageWhy]

    def __init__(
        self,
        user_id: str,
        text: Optional[str] = None,
        image: Optional[str] = None,
        audio: Optional[str] = None,
        why: Optional[MessageWhy] = None,
        who: str = "AI",
        content: Optional[str] = None,
        **kwargs,
    ):
        if content:
            deprecation_warning("The `content` parameter is deprecated. Use `text` instead.")    
            text = content  # Map 'content' to 'text'

        super().__init__(user_id=user_id, who=who, text=text, image=image, audio=audio, why=why, **kwargs)
    
    @computed_field
    @property
    def content(self) -> str:
        """
        This attribute is deprecated. Use `text` instead.

        The text content of the message. Use `text` instead.

        Returns
        -------
        str
            The text content of the message.
        """
        deprecation_warning("The `content` attribute is deprecated. Use `text` instead.")
        return self.text
    
    @content.setter
    def content(self, value):
        deprecation_warning("The `content` attribute is deprecated. Use `text` instead.")
        self.text = value

    def langchainfy(self) -> AIMessage:
        """
        Convert the internal CatMessage to a LangChain AIMessage.

        Returns
        -------
        AIMessage
            The LangChain AIMessage converted from the internal CatMessage.
        """

        return AIMessage(
            name=self.who,
            content=self.text
        )



class UserMessage(BaseMessage):
    """
    Represents a message from a user, containing text and optional multimedia content such as image and audio.

    This class is used to encapsulate the details of a message sent by a user, including the user's identifier, 
    the text content of the message, and any associated multimedia content such as image or audio files.

    Parameters
    ----------
    user_id : str
        Unique identifier for the user sending the message.
    text : Optional[str], default=None
        The text content of the message.
    image : Optional[str], default=None
        Image file URLs or base64 data URIs that represent image associated with the message.
    audio : Optional[str], default=None
       Audio file URLs or base64 data URIs that represent audio associated with the message.
    who : str, default="Human"
        The name of the message author, by default “Human”.

    Attributes
    ----------
    user_id : str
        Unique identifier for the user sending the message.
    who : str
        The name of the message author, by default “Human”.
    text : Optional[str]
        The text content of the message.
    image : Optional[str]
        Image file URLs or base64 data URIs that represent image associated with the message.
    audio : Optional[str]
       Audio file URLs or base64 data URIs that represent audio associated with the message.
    """
    who: str = "Human"

    def langchainfy(self) -> HumanMessage:
        """
        Convert the internal UserMessage to a LangChain HumanMessage.

        Returns
        -------
        HumanMessage
            The LangChain HumanMessage converted from the internal UserMessage.
        """

        content = []

        if self.text:
            content.append({"type": "text", "text": self.text})

        if self.image:
            formatted_image = self.langchainfy_image()
            if formatted_image:
                content.append(formatted_image)
        
        return HumanMessage(
            name=self.who,
            content=content
        )
    
    def langchainfy_image(self) -> dict:
        """Format an image to be sent as a data URI."""

        # If the image is a URL, download it and encode it as a data URI
        if self.image.startswith("http"):
            response = requests.get(self.image)
            if response.status_code == 200:
                # Open the image using Pillow to determine its MIME type
                img = Image.open(BytesIO(response.content))
                mime_type = img.format.lower()  # Get MIME type
                
                # Encode the image to base64
                encoded_image = base64.b64encode(response.content).decode('utf-8')
                image_uri = f"data:image/{mime_type};base64,{encoded_image}"
                
                # Add the image as a data URI with the correct MIME type
                return {"type": "image_url", "image_url": {"url": image_uri}}
            else:
                error_message = f"Unexpected error with status code {response.status_code}"
                if response.text:
                    error_message = response.text
                log.error(f"Failed to download image: {error_message} from {self.image}")

                return None
        
        return {"type": "image_url", "image_url": {"url": self.image}}